type AbciInfo = record { response : AbciResponse };
type AbciResponse = record {
  last_block_app_hash : text;
  data : text;
  version : text;
  last_block_height : text;
  app_version : opt text;
};
type Auth = variant { RegisterProvider; Manage };
type Block = record {
  last_commit : opt LastCommit;
  data : vec text;
  evidence : vec Evidence;
  header : BlockHeader;
};
type BlockHeader = record {
  height : text;
  evidence_hash : text;
  time : text;
  proposer_address : text;
  version : Version;
  chain_id : text;
  last_results_hash : text;
  app_hash : text;
  data_hash : text;
  last_commit_hash : text;
  last_block_id : BlockID;
  next_validators_hash : text;
  consensus_hash : text;
  validators_hash : text;
};
type BlockID = record { hash : text; parts : BlockPartsHeader };
type BlockParts = record { parts : vec text; header : BlockPartsHeader };
type BlockPartsHeader = record { total : int32; hash : text };
type ConsensusState = record { round_state : RoundState };
type ConsensusStrategy = variant { Equality; Threshold : nat8 };
type DumpConsensusState = record {
  round_state : DumpRoundState;
  peers : vec PeerState;
};
type DumpRoundState = record {
  height : text;
  last_commit : opt LastCommit;
  proposal_block : opt Block;
  triggered_timeout_precommit : bool;
  commit_round : int32;
  votes : vec VoteSet;
  step : int32;
  valid_block_parts : opt BlockParts;
  proposal_block_parts : opt BlockParts;
  locked_block_parts : opt BlockParts;
  last_validators : ValidatorSet;
  start_time : text;
  locked_block : opt Block;
  valid_block : opt Block;
  proposal : opt Proposal;
  commit_time : text;
  locked_round : int32;
  valid_round : int32;
  validators : ValidatorSet;
  round : int32;
};
type Evidence = record {
  height : int32;
  validator : Validator;
  time : int32;
  "type" : text;
  total_voting_power : int32;
};
type HeightVoteSet = record {
  prevotes_bit_array : text;
  precommits : vec text;
  prevotes : vec text;
  precommits_bit_array : text;
  round : int32;
};
type HttpHeader = record { value : text; name : text };
type HttpRequest = record {
  url : text;
  method : text;
  body : blob;
  headers : vec record { text; text };
};
type HttpResponse = record {
  body : blob;
  headers : vec record { text; text };
  status_code : nat16;
};
type InitArgs = record { managers : opt vec principal; demo : opt bool };
type JsonRpcError = record { code : int64; message : text };
type LastCommit = record {
  votes_bit_array : text;
  votes : vec text;
  peer_maj_23s : record {};
};
type Metrics = record {
  cyclesWithdrawn : nat;
  errUnauthorized : vec record { text; nat };
  auths : vec record { text; nat };
  responses : vec record { record { text; text; text }; nat64 };
  errNoPermission : nat64;
  inconsistentResponses : vec record { record { text; text }; nat64 };
  cyclesCharged : vec record { record { text; text }; nat };
  requests : vec record { record { text; text }; nat64 };
  errHttpOutcall : vec record { record { text; text }; nat64 };
  errHostNotAllowed : vec record { text; nat64 };
};
type NodeInfo = record {
  id : text;
  other : OtherInfo;
  listen_addr : text;
  network : text;
  channels : text;
  version : text;
  moniker : text;
  protocol_version : ProtocolVersion;
};
type OtherInfo = record { tx_index : text; rpc_address : text };
type PeerRoundState = record {
  height : text;
  catchup_commit : opt text;
  last_commit : opt text;
  precommits : opt text;
  prevotes : opt text;
  step : int32;
  proposal_block_parts : opt text;
  proposal_pol : opt text;
  start_time : text;
  proposal : bool;
  catchup_commit_round : opt int32;
  proposal_pol_round : opt int32;
  proposal_block_parts_header : opt BlockPartsHeader;
  round : int32;
  last_commit_round : opt int32;
};
type PeerState = record { node_address : text; peer_state : PeerStateInfo };
type PeerStateInfo = record { round_state : PeerRoundState; stats : PeerStats };
type PeerStats = record { block_parts : text; votes : text };
type Proposal = record {
  height : text;
  signature : text;
  block_id : BlockID;
  "type" : bool;
  pol_round : int32;
  timestamp : text;
  round : int32;
};
type Proposer = record { address : text; index : int32 };
type ProtocolVersion = record { app : text; p2p : text; block : text };
type PubKey = record { value : text; "type" : text };
type RegisterProviderArgs = record {
  id : text;
  url : text;
  auth : opt RpcAuth;
};
type RejectionCode = variant {
  NoError;
  CanisterError;
  SysTransient;
  DestinationInvalid;
  Unknown;
  SysFatal;
  CanisterReject;
};
type Result = variant { Ok : text; Err : RpcError };
type Result_1 = variant { Ok : AbciInfo; Err : RpcError };
type Result_2 = variant { Ok : ConsensusState; Err : RpcError };
type Result_3 = variant { Ok : DumpConsensusState; Err : RpcError };
type Result_4 = variant { Ok : bool; Err : RpcError };
type Result_5 = variant { Ok : Status; Err : RpcError };
type RoundState = record {
  height_vote_set : vec HeightVoteSet;
  "height/round/step" : text;
  start_time : text;
  proposal_block_hash : text;
  proposer : Proposer;
  valid_block_hash : text;
  locked_block_hash : text;
};
type RpcApi = record { network : text; headers : opt vec HttpHeader };
type RpcAuth = variant {
  QueryParam : HttpHeader;
  BearerToken : record { token : text };
  PathSegment : record { segment : text };
  HeaderParam : HttpHeader;
};
type RpcConfig = record {
  responseConsensus : opt ConsensusStrategy;
  responseSizeEstimate : opt nat64;
};
type RpcError = variant {
  JsonRpcError : JsonRpcError;
  Text : text;
  InconsistentResponse : vec record { RpcApi; text };
  ValidationError : text;
  HttpOutcallError : record { code : RejectionCode; message : text };
  ParseError : text;
};
type RpcServices = variant {
  Mainnet;
  Custom : vec RpcApi;
  Testnet;
  Devnet;
  Localnet;
  Provider : vec text;
};
type Status = record {
  node_info : NodeInfo;
  sync_info : SyncInfo;
  validator_info : ValidatorInfo;
};
type SyncInfo = record {
  earliest_app_hash : text;
  latest_app_hash : text;
  latest_block_hash : text;
  latest_block_time : text;
  earliest_block_hash : text;
  earliest_block_time : text;
  earliest_block_height : text;
  catching_up : bool;
  latest_block_height : text;
};
type UpdateProviderArgs = record {
  id : text;
  url : opt text;
  auth : opt RpcAuth;
};
type Validator = record {
  address : text;
  pub_key : PubKey;
  voting_power : text;
};
type ValidatorInfo = record {
  address : text;
  pub_key : PubKey;
  voting_power : text;
};
type ValidatorPriority = record {
  proposer_priority : text;
  address : text;
  pub_key : PubKey;
  voting_power : text;
};
type ValidatorSet = record {
  proposer : ValidatorPriority;
  validators : vec ValidatorPriority;
};
type Version = record { app : text; block : text };
type VoteSet = record {
  prevotes_bit_array : text;
  precommits : opt vec text;
  prevotes : opt vec text;
  precommits_bit_array : text;
  round : int32;
};
service : (InitArgs) -> {
  authorize : (principal, Auth) -> (bool);
  deauthorize : (principal, Auth) -> (bool);
  getAuthorized : (Auth) -> (vec principal) query;
  getMetrics : () -> (Metrics) query;
  getNodesInSubnet : () -> (nat32) query;
  getProviders : () -> (vec text) query;
  http_request : (HttpRequest) -> (HttpResponse) query;
  registerProvider : (RegisterProviderArgs) -> ();
  request : (RpcServices, text, text, opt nat64) -> (Result);
  requestCost : (text, nat64) -> (nat) query;
  sol_getAbciInfo : (RpcServices, opt RpcConfig) -> (Result_1);
  sol_getConsensusState : (RpcServices, opt RpcConfig) -> (Result_2);
  sol_getDumpConsensusState : (RpcServices, opt RpcConfig) -> (Result_3);
  sol_getHealth : (RpcServices, opt RpcConfig) -> (Result_4);
  sol_getStatus : (RpcServices, opt RpcConfig) -> (Result_5);
  unregisterProvider : (text) -> (bool);
  updateProvider : (UpdateProviderArgs) -> ();
}
